= Cloudera PVC Terraform Automation Guide
# cdp-onprem-automation
Terraform and Ansible based automation to spin-up multi node Cloudera PvC (OnPrem) Cluster

v0.1, May 2025: Draft

// :toc: macro
:toc-title: Table of Contents
:description: Installation instructions for Cloudera OnPrem Cluster nodes on AWS
:toc: left
:toclevels: 2
:icons: font
:sectnums:
:sectnumlevels: 3
:source-highlighter: rouge
:keywords: Cloudera, Terraform, AWS, Automation, PVC
:imagesdir: ./images
:hide-uri-scheme:
:homepage: https://github.com/kuldeepsahu1105/cdp-onprem-automation

[WARNING]
====
üìù **DRAFT** ‚Äî This document is WIP and Not Final.
====

A comprehensive guide to automate the provisioning of Cloudera Data Platform (CDP) cluster instances on AWS.

== Overview

This automation facilitates the provisioning of a Cloudera Private Cloud (PVC) environment on AWS using Terraform. It supports both Mac and Linux systems and offers two primary methods for deployment:

. *Wrapper Script Method*
. *Manual Terraform Method*

== Prerequisites

Ensure the following tools and accounts are available before proceeding:

- *AWS Account*
- *AWS CLI*
- *Terraform*
- *Git*
- *MacOS or Linux OS*

== Deployment Methods

=== Wrapper Script Method

This is the quickest method for setting up your infrastructure.

==== Steps

. Download the wrapper script and environment file:

[source, bash]
----
curl -O https://raw.githubusercontent.com/kuldeepsahu1105/cdp-onprem-automation/dev/terraform/clone_and_run_terraform.sh
curl -O https://raw.githubusercontent.com/kuldeepsahu1105/cdp-onprem-automation/dev/terraform/.tfvars.env
----

. Configure `.tfvars.env`:

Edit the file to match your desired configuration. See the <<tfvars-configuration, .tfvars.env Configuration Guide>> for details.

. Execute the script:

[source, bash]
----
bash clone_and_run_terraform.sh
----

Ensure `.tfvars.env` is in the same directory as the script.

=== Manual Terraform Method

This method provides more granular control over the deployment process.

==== Steps

. Clone the repository:

[source, bash]
----
git clone https://github.com/kuldeepsahu1105/cdp-onprem-automation.git
cd cdp-onprem-automation
----

. Configure `terraform.tfvars`:

Modify the file to fit your desired setup. Refer to the <<tfvars-configuration, .tfvars.env Configuration Guide>>.

. Initialize and apply the Terraform configuration:

[source, bash]
----
terraform init
terraform apply
----

== .tfvars.env Configuration Guide

The `.tfvars.env` file defines environment-specific settings used by Terraform.

=== AWS Region and Environment Settings

[source, bash]
----
AWS_REGION="${AWS_REGION:-ap-southeast-1}"
OWNER="${OWNER:-ksahu}"
ENVIRONMENT="${ENVIRONMENT:-development}"
TERRAFORM_VERSION="${TERRAFORM_VERSION:-latest}"
----

- `AWS_REGION`: AWS region for deployment
- `OWNER`: Resource tag owner
- `ENVIRONMENT`: Environment name (e.g., dev, stage, prod)
- `TERRAFORM_VERSION`: Terraform version to install and use (if terraform is not installed)

=== VPC Configuration

[source, bash]
----
-var="create_vpc=false"
-var="vpc_name=cloudera-vpc"
-var="vpc_cidr_block=172.16.0.0/16"
-var='azs=["ap-southeast-1a","ap-southeast-1b"]'
-var='public_subnets_cidr=["172.16.0.0/24"]'
-var='private_subnets_cidr=[]'
-var="enable_nat_gateway=false"
-var="enable_vpn_gateway=false"
----

=== Security Group Configuration

[source, bash]
----
-var="create_new_sg=false"
-var='allowed_cidrs=["0.0.0.0/0"]'
-var='allow_all=true'
-var='allowed_ports=[22, 443, 80, 7180, 7183, 7182]'
-var="sg_name=pvc_cluster_sg"
-var="existing_sg=sg-0dbb6f79cba5ef701"
----

=== Elastic IP and Key Pair Configuration

[source, bash]
----
-var="create_eip=true"
-var="cldr_eip_name=cldr-mngr-eip"

-var="create_keypair=true"
-var="keypair_name=pvc-new-keypair"
-var="existing_keypair_name=kuldeep-pvc-session"
----

=== Instance Groups Configuration

[source, bash]
----
-var='instance_groups={
  cldr_mngr = {
    count = 1
    ami = "ami-06dc977f58c8d7857"
    instance_type = "m5.8xlarge"
    volume_size = 1500
    tags = { Name = "'"${ENVIRONMENT}"'-cldr-mngr" }
  },
  ipa_server = {
    count = 1
    ami = "ami-06dc977f58c8d7857"
    instance_type = "m5.4xlarge"
    volume_size = 250
    tags = { Name = "'"${ENVIRONMENT}"'-ipa-server" }
  },
  pvcbase_master = {
    count = 1
    ami = "ami-06dc977f58c8d7857"
    instance_type = "m5.8xlarge"
    volume_size = 1000
    tags = { Name = "'"${ENVIRONMENT}"'-pvcbase-master" }
  },
  pvcbase_worker = {
    count = 5
    ami = "ami-06dc977f58c8d7857"
    instance_type = "m5.8xlarge"
    volume_size = 1000
    tags = { Name = "'"${ENVIRONMENT}"'-pvcbase-worker" }
  },
  pvcecs_master = {
    count = 1
    ami = "ami-06dc977f58c8d7857"
    instance_type = "m5.8xlarge"
    volume_size = 2300
    tags = { Name = "'"${ENVIRONMENT}"'-pvcecs-master" }
  },
  pvcecs_worker = {
    count = 10
    ami = "ami-06dc977f58c8d7857"
    instance_type = "m5.8xlarge"
    volume_size = 2300
    tags = { Name = "'"${ENVIRONMENT}"'-pvcecs-worker" }
  }
}'
----

== Best Practices

- *Version Control*: Store all infrastructure code in Git.
- *Remote State*: Use remote backends like S3 with DynamoDB for secure state storage.
- *Modularization*: Organize Terraform into reusable modules.
- *Variable Management*: Use `.tfvars` files and environment overrides for clean configuration.
